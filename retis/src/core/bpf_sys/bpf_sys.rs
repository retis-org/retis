#![allow(dead_code)]

use std::io::{Error, Result};
use std::mem;
use std::os::raw::c_long;

// Embed in a mod to skip the linter
mod bpf_gen {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]
    // Clippy warns for code generated by bindgen,
    // skip it for this module
    #![allow(clippy::all)]
    include!(concat!(env!("OUT_DIR"), "/bpf_gen.rs"));
}

pub(crate) use bpf_gen::*;

fn bpf_sys(cmd: bpf_gen::bpf_cmd, attr: &bpf_gen::bpf_attr, size: u32) -> c_long {
    unsafe { libc::syscall(libc::SYS_bpf, cmd, attr, size) }
}

pub(crate) fn bpf(cmd: bpf_gen::bpf_cmd, attr: &bpf_gen::bpf_attr) -> Result<u32> {
    let r = bpf_sys(cmd, attr, mem::size_of::<bpf_gen::bpf_attr>() as u32);
    if r < 0 {
        return Err(Error::last_os_error());
    }

    Ok(r as u32)
}

pub(crate) fn bpf_unload(fd: u32) -> Result<()> {
    let r = unsafe { libc::close(fd as libc::c_int) };
    if r < 0 {
        return Err(Error::last_os_error());
    }

    Ok(())
}
