//! Implementation of the Retis events factory, handling events generated by the
//! Retis userspace directly.

use std::{collections::VecDeque, sync::Mutex};

use anyhow::Result;

use crate::events::{helpers::time::*, *};

/// Retis events factory; allowing collectors and Retis core parts to generate
/// events and augment the collection.
#[derive(Default)]
pub(crate) struct RetisEventsFactory {
    queue: Mutex<VecDeque<Event>>,
}

// Mutex is Send + Sync.
unsafe impl Send for RetisEventsFactory {}
unsafe impl Sync for RetisEventsFactory {}

impl RetisEventsFactory {
    /// Retrieve the next event, if any. Returns None if no event is currently
    /// available.
    pub(crate) fn next_event(&self) -> Option<Event> {
        self.queue.lock().unwrap().pop_front()
    }

    /// Add a new event. The provided closure accepts an event whose
    /// `common` section has already been initialized and is expected
    /// to add additional sections to it.
    pub(crate) fn add_event<F>(&self, f: F) -> Result<()>
    where
        F: Fn(&mut Event) -> Result<()>,
    {
        let mut event = Event::new();
        event.common = Some(CommonEvent {
            timestamp: monotonic_timestamp()?,
            ..Default::default()
        });

        f(&mut event)?;
        self.queue.lock().unwrap().push_front(event);
        Ok(())
    }
}
