/// # Writer handling file rotation
use std::{
    ffi::OsStr,
    fs::{self, File, OpenOptions},
    io::{self, BufRead, BufReader, BufWriter, Read, Seek, SeekFrom, Write},
    ops::Drop,
    path::{Path, PathBuf},
};

use anyhow::{anyhow, Result};
use log::{error, info, warn};
use nix::sys::utsname::uname;

use crate::{compat::json, file::guess_version, helpers::time::*, *};

/// Rotation policy, aka how the output files are split depending on internal
/// rules.
#[event_type]
#[derive(Copy, Eq, PartialEq)]
pub enum RotationPolicy {
    /// Split the output file based on its size.
    Size(usize),
}

/// Writing to a file while following a rotation policy, which if conditions are
/// met can generate multiple files spreading the overall input. A startup event
/// is added at the top of all files generated by the writer.
pub struct RotateWriter {
    inner: BufWriter<File>,
    // Controls how rotation is done.
    policy: Option<RotationPolicy>,
    // Target file name for the output. Will be suffixed following the rotation
    // policy rules.
    target: PathBuf,
    // Current index of the file being written, starting with 0.
    index: u32,
    // Total bytes written across the set of split files.
    written: usize,
    // Monotonic clock offset, cached for using it in the initial events.
    monotonic_offset: TimeSpec,
}

impl RotateWriter {
    /// Create a new `RotateWriter` given a file path and a rotation policy.
    pub fn new<P: AsRef<Path>>(
        file: P,
        policy: Option<RotationPolicy>,
        monotonic_offset: TimeSpec,
    ) -> Result<Self> {
        // Generate a startup event.
        let index = 0;
        let startup = serde_json::to_vec(&startup_event(monotonic_offset, index, policy)?)?;

        let (inner, written) = Self::new_file(file.as_ref(), &startup)?;

        Ok(Self {
            inner,
            policy,
            target: file.as_ref().to_path_buf(),
            index,
            written,
            monotonic_offset,
        })
    }

    fn new_file(target: &Path, head: &[u8]) -> io::Result<(BufWriter<File>, usize)> {
        let mut w = BufWriter::new(
            OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(target)?,
        );

        let mut written = w.write(head)?;
        written += w.write(b"\n")?;

        Ok((w, written))
    }

    fn close(&mut self) -> io::Result<()> {
        // Flush the current buffer.
        self.flush()?;

        // Move the file, if needed.
        if let Some(policy) = &self.policy {
            match policy {
                RotationPolicy::Size(_) => {
                    let mut target = self.target.clone().into_os_string();
                    target.push(format!(".{}", self.index));

                    fs::rename(&self.target, &target)?;

                    // The `Size` policy suffix the output file with their index; we
                    // can reuse the internal index here.
                    self.index += 1;
                }
            }
        }

        Ok(())
    }

    /// Rotate the file.
    fn rotate(&mut self) -> io::Result<()> {
        if self.policy.is_none() {
            return Err(io::Error::new(
                io::ErrorKind::Unsupported,
                "Cannot rotate output without a rotation policy",
            ));
        }

        // Close and rename the target file.
        self.close()?;

        // Generate a startup event.
        let startup = serde_json::to_vec(
            &startup_event(self.monotonic_offset, self.index, self.policy)
                .map_err(io::Error::other)?,
        )
        .map_err(io::Error::other)?;

        // Create the new file.
        (self.inner, self.written) = Self::new_file(&self.target, &startup)?;

        Ok(())
    }
}

impl Write for RotateWriter {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        if let Some(policy) = &self.policy {
            match policy {
                RotationPolicy::Size(limit) => {
                    if self.written + buf.len() > *limit {
                        self.rotate()?;
                    }
                }
            }
        }

        let written = self.inner.write(buf)?;
        self.written += written;

        Ok(written)
    }

    fn flush(&mut self) -> io::Result<()> {
        self.inner.flush()
    }
}

impl Drop for RotateWriter {
    fn drop(&mut self) {
        if let Err(e) = self.close() {
            error!("Could not close {}: {e}", self.target.display());
            return;
        }

        info!("Wrote {} event file(s)", self.index);
    }
}

/// Generate an event with the startup section. This is used at
/// post-processing time to have insights about the collection environment.
pub(crate) fn startup_event(
    clock_monotonic_offset: TimeSpec,
    index: u32,
    policy: Option<RotationPolicy>,
) -> Result<Event> {
    let mut event = Event::new();
    event.common = Some(CommonEvent {
        timestamp: monotonic_timestamp()?,
        ..Default::default()
    });

    let uname = uname().map_err(|e| anyhow!("Failed to get system information: {e}"))?;
    let release = uname.release().to_string_lossy();
    let version = uname.version().to_string_lossy();
    let machine = uname.machine().to_string_lossy();

    event.startup = Some(StartupEvent {
        retis_version: option_env!("RELEASE_VERSION")
            .unwrap_or("unspec")
            .to_string(),
        clock_monotonic_offset,
        machine: MachineInfo {
            kernel_release: release.to_string(),
            kernel_version: version.to_string(),
            hardware_name: machine.to_string(),
        },
        split_file: policy.map(|policy| SplitFile { id: index, policy }),
    });

    Ok(event)
}

/// Given a file name, reads it following a rotation policy. The rotation policy
/// is detected automatically.
pub struct RotateReader {
    inner: File,
    // Controls how rotation is done.
    policy: Option<RotationPolicy>,
    // Target file name for the output. Will be suffixed following the rotation
    // policy rules.
    target: PathBuf,
    // Index of the next file to read.
    next_index: u32,
}

impl RotateReader {
    pub fn new<P: AsRef<Path>>(file: P, try_split: bool) -> Result<Self> {
        let (target, index, policy) = Self::detect_policy(file.as_ref(), try_split)?;
        if let Some(policy) = &policy {
            log::debug!(
                "Opening {} with rotation policy {policy:?}",
                target.display()
            );
        }

        Ok(Self {
            inner: Self::open_file(&target, index, policy)?
                .ok_or_else(|| anyhow!("Could not open {}", target.display()))?,
            policy,
            target,
            next_index: index + 1,
        })
    }

    /// Detects a rotation policy given an input file name.
    fn detect_policy(
        path: &Path,
        try_split: bool,
    ) -> Result<(PathBuf, u32, Option<RotationPolicy>)> {
        // First, try the target file.
        if path.is_file() {
            return Self::detect_policy_from_events(&path.to_path_buf());
        }

        // If allowed, fallback to trying using a known split file extension.
        if try_split {
            let target = PathBuf::from(format!("{}.0", path.display()));
            if target.is_file() {
                return Self::detect_policy_from_events(&target);
            }
        }

        Err(anyhow!("Cannot open {}", path.display()))
    }

    /// Given a file, detect the rotation policy reading the startup event, if
    /// any. It's important to check for the file existence before to throw real
    /// errors from this.
    ///
    /// Returns the target file base (filename w/o the split extension), index
    /// and rotation policy).
    fn detect_policy_from_events(path: &PathBuf) -> Result<(PathBuf, u32, Option<RotationPolicy>)> {
        // Use a temporary BufReader to benefit from the `read_line`
        // implementation.
        let mut reader = BufReader::new(File::open(path)?);
        let mut path = path.clone();

        let mut line = String::new();
        if reader.read_line(&mut line)? == 0 {
            // File is empty, which is valid from our PoV here.
            return Ok((path, 0, None));
        }

        // Get the startup event in a 2-step way, to allow for backward
        // compatibility logic to kick in.
        let event: Event = match serde_json::from_str(line.as_str())? {
            serde_json::Value::Object(ref obj) => {
                json::from_str(line.as_str(), guess_version(obj)?)?
            }
            // Not supporting stored series here.
            _ => return Ok((path, 0, None)),
        };

        if let Some(startup) = event.startup {
            if let Some(split) = startup.split_file {
                match split.policy {
                    RotationPolicy::Size(_) => {
                        if path.extension()
                            == Some(<String as AsRef<OsStr>>::as_ref(&format!("{}", split.id)))
                        {
                            path.set_extension("");
                            return Ok((path, split.id, Some(split.policy)));
                        } else {
                            warn!("File extension does not match the rotation policy");
                        }
                    }
                }
            }
        }

        Ok((path, 0, None))
    }

    fn open_file(
        target: &Path,
        index: u32,
        policy: Option<RotationPolicy>,
    ) -> io::Result<Option<File>> {
        let target = match policy {
            Some(RotationPolicy::Size(_)) => PathBuf::from(format!("{}.{index}", target.display())),
            None => target.to_path_buf(),
        };
        if !target.is_file() {
            return Ok(None);
        }
        Ok(Some(File::open(target)?))
    }
}

impl Read for RotateReader {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        let read = self.inner.read(buf)?;
        if read > 0 {
            return Ok(read);
        }

        if self.policy.is_none() {
            return Ok(0);
        }

        // EOF reached, come up with next file to open (if any).
        self.inner = match Self::open_file(&self.target, self.next_index, self.policy)? {
            Some(file) => file,
            // Last file was processed.
            None => return Ok(0),
        };
        self.next_index += 1;

        // Try reading again.
        self.read(buf)
    }
}

impl Seek for RotateReader {
    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {
        // We only support seeking in the current file.
        self.inner.seek(pos)
    }
}
