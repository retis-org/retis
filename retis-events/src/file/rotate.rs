/// # Writer handling file rotation
use std::{
    fs::{self, File, OpenOptions},
    io::{self, BufWriter, Write},
    ops::Drop,
    path::{Path, PathBuf},
};

use anyhow::{anyhow, Result};
use log::{error, info};
use nix::sys::utsname::uname;

use crate::{helpers::time::*, *};

/// Rotation policy, aka how the output files are split depending on internal
/// rules.
#[event_type]
#[derive(Copy, Eq, PartialEq)]
pub enum RotationPolicy {
    /// Split the output file based on its size.
    Size(usize),
}

/// Writing to a file while following a rotation policy, which if conditions are
/// met can generate multiple files spreading the overall input. A startup event
/// is added at the top of all files generated by the writer.
pub struct RotateWriter {
    inner: BufWriter<File>,
    // Controls how rotation is done.
    policy: Option<RotationPolicy>,
    // Target file name for the output. Will be suffixed following the rotation
    // policy rules.
    target: PathBuf,
    // Current index of the file being written, starting with 0.
    index: u32,
    // Total bytes written across the set of split files.
    written: usize,
    // Monotonic clock offset, cached for using it in the initial events.
    monotonic_offset: TimeSpec,
}

impl RotateWriter {
    /// Create a new `RotateWriter` given a file path and a rotation policy.
    pub fn new<P: AsRef<Path>>(
        file: P,
        policy: Option<RotationPolicy>,
        monotonic_offset: TimeSpec,
    ) -> Result<Self> {
        // Generate a startup event.
        let index = 0;
        let startup = serde_json::to_vec(&startup_event(monotonic_offset, index, policy)?)?;

        let (inner, written) = Self::new_file(file.as_ref(), &startup)?;

        Ok(Self {
            inner,
            policy,
            target: file.as_ref().to_path_buf(),
            index,
            written,
            monotonic_offset,
        })
    }

    fn new_file(target: &Path, head: &[u8]) -> io::Result<(BufWriter<File>, usize)> {
        let mut w = BufWriter::new(
            OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(target)?,
        );

        let mut written = w.write(head)?;
        written += w.write(b"\n")?;

        Ok((w, written))
    }

    fn close(&mut self) -> io::Result<()> {
        // Flush the current buffer.
        self.flush()?;

        // Move the file, if needed.
        if let Some(policy) = &self.policy {
            match policy {
                RotationPolicy::Size(_) => {
                    let mut target = self.target.clone().into_os_string();
                    target.push(format!(".{}", self.index));

                    fs::rename(&self.target, &target)?;

                    // The `Size` policy suffix the output file with their index; we
                    // can reuse the internal index here.
                    self.index += 1;
                }
            }
        }

        Ok(())
    }

    /// Rotate the file.
    fn rotate(&mut self) -> io::Result<()> {
        if self.policy.is_none() {
            return Err(io::Error::new(
                io::ErrorKind::Unsupported,
                "Cannot rotate output without a rotation policy",
            ));
        }

        // Close and rename the target file.
        self.close()?;

        // Generate a startup event.
        let startup = serde_json::to_vec(
            &startup_event(self.monotonic_offset, self.index, self.policy)
                .map_err(io::Error::other)?,
        )
        .map_err(io::Error::other)?;

        // Create the new file.
        (self.inner, self.written) = Self::new_file(&self.target, &startup)?;

        Ok(())
    }
}

impl Write for RotateWriter {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        if let Some(policy) = &self.policy {
            match policy {
                RotationPolicy::Size(limit) => {
                    if self.written + buf.len() > *limit {
                        self.rotate()?;
                    }
                }
            }
        }

        let written = self.inner.write(buf)?;
        self.written += written;

        Ok(written)
    }

    fn flush(&mut self) -> io::Result<()> {
        self.inner.flush()
    }
}

impl Drop for RotateWriter {
    fn drop(&mut self) {
        if let Err(e) = self.close() {
            error!("Could not close {}: {e}", self.target.display());
            return;
        }

        info!("Wrote {} event file(s)", self.index);
    }
}

/// Generate an event with the startup section. This is used at
/// post-processing time to have insights about the collection environment.
pub(crate) fn startup_event(
    clock_monotonic_offset: TimeSpec,
    index: u32,
    policy: Option<RotationPolicy>,
) -> Result<Event> {
    let mut event = Event::new();
    event.common = Some(CommonEvent {
        timestamp: monotonic_timestamp()?,
        ..Default::default()
    });

    let uname = uname().map_err(|e| anyhow!("Failed to get system information: {e}"))?;
    let release = uname.release().to_string_lossy();
    let version = uname.version().to_string_lossy();
    let machine = uname.machine().to_string_lossy();

    event.startup = Some(StartupEvent {
        retis_version: option_env!("RELEASE_VERSION")
            .unwrap_or("unspec")
            .to_string(),
        clock_monotonic_offset,
        machine: MachineInfo {
            kernel_release: release.to_string(),
            kernel_version: version.to_string(),
            hardware_name: machine.to_string(),
        },
        split_file: policy.map(|policy| SplitFile { id: index, policy }),
    });

    Ok(event)
}
