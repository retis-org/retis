#![allow(dead_code)]

use std::io::{Error, Result};
use std::mem;
use std::os::raw::c_long;

// Embed in a mod to skip the linter
mod bpf_gen {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]
    // Clippy warns for code generated by bindgen,
    // skip it for this module
    #![allow(clippy::all)]
    include!(concat!(env!("OUT_DIR"), "/bpf_gen.rs"));
}

pub(crate) use bpf_gen::{bpf_attr, bpf_cmd};

fn bpf_sys(cmd: bpf_cmd, attr: &bpf_attr, size: u32) -> c_long {
    unsafe { libc::syscall(libc::SYS_bpf, cmd, attr, size) }
}

pub(crate) fn bpf(cmd: bpf_cmd, attr: &bpf_attr) -> Result<u32> {
    let r = bpf_sys(cmd, attr, mem::size_of::<bpf_attr>() as u32);
    if r < 0 {
        return Err(Error::last_os_error());
    }

    Ok(r as u32)
}

pub(crate) fn bpf_unload(fd: u32) -> Result<()> {
    let r = unsafe { libc::close(fd as libc::c_int) };
    if r < 0 {
        return Err(Error::last_os_error());
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use std::ffi::CString;
    use std::{ptr, str};

    use super::*;

    const LOG_SIZE: usize = 64 * 1024;
    const INSN_SIZE: usize = 8;

    #[test]
    #[cfg_attr(not(feature = "test_cap_bpf"), ignore)]
    fn load_xdp_insns() {
        let log_buff: [u8; LOG_SIZE] = [0; LOG_SIZE];

        // The bytecode below was generated from the following:
        // int xdp_prog_simple(struct xdp_md *ctx)
        // {
        //     if (!ctx)
        //         return XDP_PASS;
        //
        //     if ((__u16 *)ctx->data + 1 > (__u16 *)ctx->data_end)
        //         return XDP_PASS;
        //
        //     __u16 *data = (void *)(long)ctx->data;
        //     if (bpf_ntohs(*data) == 0xeB9F) {
        //         *data = 0xffff;
        //     }
        //
        //     return XDP_PASS;
        // }
        // explicitly skip rustfmt checks as we want to format the
        // array per-instruction. Ideally, this should be generated.
        #[rustfmt::skip]
        let prog: [u8; 12 * INSN_SIZE] = [
              0x15, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x61, 0x12, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x61, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              0xbf, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x07, 0x03, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
              0x2d, 0x23, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x69, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x55, 0x02, 0x02, 0x00, 0xeb, 0x9f, 0x00, 0x00,
              0xb7, 0x02, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
              0x6b, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              0xb7, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
              0x95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let mut attrs: bpf_attr = unsafe { std::mem::zeroed() };
        let load_attrs = unsafe { &mut attrs.__bindgen_anon_3 };

        load_attrs.prog_type = bpf_gen::bpf_prog_type::BPF_PROG_TYPE_XDP as u32;

        let prog_name = CString::new("xdp_simple").expect("new string for prog name failed");
        unsafe {
            ptr::copy_nonoverlapping(
                prog_name.as_ptr(),
                load_attrs.prog_name.as_mut_ptr(),
                load_attrs.prog_name.len(),
            )
        };
        load_attrs.insns = prog.as_ptr() as u64;
        load_attrs.insn_cnt = (prog.len() / INSN_SIZE) as u32;
        let license = CString::new("GPL").expect("new string for license failed");
        load_attrs.license = license.as_ptr() as u64;
        load_attrs.log_level = 2;
        load_attrs.log_buf = log_buff.as_ptr() as u64;
        load_attrs.log_size = LOG_SIZE as u32;

        let res = bpf(bpf_cmd::BPF_PROG_LOAD, &attrs);
        println!("{}", str::from_utf8(&log_buff).unwrap());

        assert!(res.is_ok());

        let fd = res.unwrap();
        const DATA_SZ: usize = 2;

        let data_in: [u8; DATA_SZ] = [0xeB, 0x9F];
        let data_out: [u8; DATA_SZ] = [0; 2];

        attrs = unsafe { std::mem::zeroed() };
        let test_attrs = unsafe { &mut attrs.test };

        test_attrs.data_in = data_in.as_ptr() as u64;
        test_attrs.data_size_in = data_in.len() as u32;
        test_attrs.data_out = data_out.as_ptr() as u64;
        test_attrs.data_size_out = data_out.len() as u32;
        test_attrs.prog_fd = fd;

        assert!(bpf(bpf_cmd::BPF_PROG_TEST_RUN, &attrs).is_ok());
        assert_eq!(u16::from_ne_bytes(data_out), 0xffff);

        bpf_unload(fd).expect("failed to unload bpf program");
    }
}
